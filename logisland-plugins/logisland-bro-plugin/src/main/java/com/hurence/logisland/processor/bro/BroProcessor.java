/**
 * Copyright (C) 2017 Hurence
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hurence.logisland.processor.bro;

import com.hurence.logisland.annotation.documentation.CapabilityDescription;
import com.hurence.logisland.annotation.documentation.Tags;
import com.hurence.logisland.component.PropertyDescriptor;
import com.hurence.logisland.processor.*;
import com.hurence.logisland.record.Field;
import com.hurence.logisland.record.FieldDictionary;
import com.hurence.logisland.record.FieldType;
import com.hurence.logisland.record.Record;
import com.hurence.logisland.util.string.JsonUtil;
import com.hurence.logisland.validator.StandardValidators;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Bro (https://www.bro.org/) processor
 */
@Tags({"bro"})
@CapabilityDescription(
        "The Bro (https://www.bro.org) processor is the Logisland entry point to get and process Bro events."
        + " The Bro-Kafka plugin (https://github.com/bro/bro-plugins/tree/master/kafka ) should be used and configured"
        + " in order to have Bro events sent to Kafka  Then this Bro processor will do some minor pre-processing on"
        + " incoming Bro events to adapt them to Logisland. Then following processor in the stream can then process the"
        + " Bro events generated by this Bro processor.")
public class BroProcessor extends AbstractProcessor {

    private static Logger logger = LoggerFactory.getLogger(BroProcessor.class);
    
    private static Map<String, String> broFieldToLogislandField = new HashMap<String, String>();
    
    // Bro conn fields
    private static final String BRO_CONN_ID_ORIG_H = "id.orig_h";
    private static final String BRO_CONN_ID_RESP_H = "id.resp_h";
    private static final String BRO_CONN_ID_ORIG_P = "id.orig_p";
    private static final String BRO_CONN_ID_RESP_P = "id.resp_p";
    
    // Logisland conn fields
    
    private static final String LOGISLAND_CONN_SOURCE_IP = "source_ip";
    private static final String LOGISLAND_CONN_DEST_IP = "dest_ip";
    private static final String LOGISLAND_CONN_SOURCE_PORT = "source_port";
    private static final String LOGISLAND_CONN_DEST_PORT = "dest_port";
    
    static {
        // Bro conn fields mapping
        broFieldToLogislandField.put(BRO_CONN_ID_ORIG_H, LOGISLAND_CONN_SOURCE_IP);
        broFieldToLogislandField.put(BRO_CONN_ID_RESP_H, LOGISLAND_CONN_DEST_IP);
        broFieldToLogislandField.put(BRO_CONN_ID_ORIG_P, LOGISLAND_CONN_SOURCE_PORT);
        broFieldToLogislandField.put(BRO_CONN_ID_RESP_P, LOGISLAND_CONN_DEST_PORT);
    }

    private boolean debug = false;
    
    private static final String KEY_DEBUG = "debug";
    
    public static final PropertyDescriptor DEBUG = new PropertyDescriptor.Builder()
            .name(KEY_DEBUG)
            .description("Enable debug. If enabled, the original JSON string is embedded in the record_value field of the record.")
            .addValidator(StandardValidators.BOOLEAN_VALIDATOR)
            .required(false)
            .build();

    @Override
    public void init(final ProcessContext context)
    {
        logger.debug("Initializing Bro Processor");
    }
    
    @Override
    public List<PropertyDescriptor> getSupportedPropertyDescriptors() {
        
        final List<PropertyDescriptor> descriptors = new ArrayList<>();
        descriptors.add(DEBUG);

        return Collections.unmodifiableList(descriptors);
    }
  
    @Override
    public Collection<Record> process(ProcessContext context, Collection<Record> records)
    {
        logger.debug("Bro Processor records " + records);

        /**
         * Get the original Bro event as a JSON string and do some adaptation like
         * changing some field names:
         * - Bro field names with '.' are not acceptable for indexing into ES. Change them with something more
         * user friendly if needed but in any case, replace the ES unwanted characters like '.'.
         */
        for (Record record : records)
        {
            String recordValue = (String)record.getField(FieldDictionary.RECORD_VALUE).getRawValue();
            
            // Parse as JSON object
            Map<String, Object> jsonBroEvent = JsonUtil.convertJsonToMap(recordValue);

            if (jsonBroEvent.isEmpty())
            {
                logger.error("Empty Bro event or error while parsing it: " + record);
                continue;
            }
            
            if (jsonBroEvent.size() != 1)
            {
                logger.error("Bro event should have one bro event type field: " + record);
                continue;
            }
            
            Map.Entry<String, Object> eventTypeAndValue = jsonBroEvent.entrySet().iterator().next();
            
            String broEventType = eventTypeAndValue.getKey();
            Object broEventValue = eventTypeAndValue.getValue();
            
            Map<String, Object> finalBroEvent = null; 
            try {
                finalBroEvent = (Map<String, Object>)broEventValue;
            } catch(Throwable t)
            {
                logger.error("Cannot understand bro event content: " + record);
                continue;
            }
            
            if (debug)    
            {
                // Log original JSON string in record_value for debug purpose
                // Clone the map so that even if we change keys in the map, the original key values are kept
                // in the record_value field
                Map<String, Object> normalizedMap = cloneMap(finalBroEvent);
                normalizeFields(normalizedMap, null);   
                record.setField(new Field(FieldDictionary.RECORD_VALUE, FieldType.MAP, normalizedMap));
            } else
            {
                record.removeField(FieldDictionary.RECORD_VALUE);
            }

            normalizeFields(finalBroEvent, broFieldToLogislandField);                       
            
            setBroEventFieldsAsFirstLevelFields(finalBroEvent, record);

            // Overwrite default reord_type field to indicate to ES processor which index type to use 
            // (index type is the bro event type)
            record.setStringField(FieldDictionary.RECORD_TYPE, broEventType);
            
            logger.debug("new Bro record: " + record);
        }

        logger.debug("################## Bro Processor output records " + records);
        return records;
    }
    
    /**
     * Gets the JSON content 
     * @param record
     */
    private static void setBroEventFieldsAsFirstLevelFields(Map<String, Object> broEvent, Record record)
    {
        for (Map.Entry<String, Object> jsonEntry : broEvent.entrySet())
        {
            String key = jsonEntry.getKey();
            Object value = jsonEntry.getValue();
            if (value instanceof String)
            {
                record.setStringField(key, value.toString());
            } else if (value instanceof Integer)
            {
                record.setField(new Field(key, FieldType.INT, value));
            } else if (value instanceof Long)
            {
                record.setField(new Field(key, FieldType.LONG, value));
            } else if (value instanceof ArrayList)
            {
                record.setField(new Field(key, FieldType.ARRAY, value));
            } else if (value instanceof Float)
            {
                record.setField(new Field(key, FieldType.FLOAT, value));
            } else if (value instanceof Double)
            {
                record.setField(new Field(key, FieldType.DOUBLE, value));
            } else if (value instanceof Map)
            {
                record.setField(new Field(key, FieldType.MAP, value));
            } else if (value instanceof Boolean)
            {
                record.setField(new Field(key, FieldType.BOOLEAN, value));
            } else
            {
                // Unrecognized value type, use string
                record.setStringField(key, JsonUtil.convertToJson(value));
            }
        }
    }
    
    /**
     * Deeply clones the passed map regarding keys
     */
    private static Map<String, Object> cloneMap(Map<String, Object> origMap)
    {
        Map<String, Object> finalMap = new HashMap<String, Object>();
        origMap.forEach( (key, value) -> {
            if (value instanceof Map)
            {
                Map<String, Object> map = (Map<String, Object>)value;
                finalMap.put(key, (Object)cloneMap(map)); 
            } else
            {
                finalMap.put(key, value);
            }
        });
        return finalMap;
    }
    
    /**
     * Normalize keys in the JSON
     * Change special keys or remove ES unwanted characters in JSON field keys
     * @param broEvent
     */
    private static void normalizeFields(Map<String, Object> broEvent, Map<String, String> oldToNewKeys)
    {
        List<String> keys = new ArrayList<String>(); // Do not modify the map while iterating over it
        for (String key : broEvent.keySet())
        {
            keys.add(key);
        }
        for (String key : keys)
        {
            Object value = broEvent.get(key);
            // Is it a key to replace ?
            String newKey = null;
            if ( (oldToNewKeys != null) && oldToNewKeys.containsKey(key) )
            {
                newKey = oldToNewKeys.get(key);
            } else
            {
                // Not a special key to replace but we must at least remove unwanted characters
                if (key.contains("."))
                {
                    newKey = key.replaceAll("\\.", "_");
                }
            }            
            
            // Compute new value
            Object newValue = null;
            if (value instanceof Map)
            {
                Map<String, Object> map = (Map<String, Object>)value;
                normalizeFields(map, oldToNewKeys);
                newValue = map;
            } else
            {
                newValue = value;
            }
            
            if (newKey != null)
            {
                broEvent.remove(key);
                broEvent.put(newKey, newValue);
            }   
        }
    }
    
    @Override
    public void onPropertyModified(PropertyDescriptor descriptor, String oldValue, String newValue) {

        logger.debug("property {} value changed from {} to {}", descriptor.getName(), oldValue, newValue);
        
        if (descriptor.getName().equals(KEY_DEBUG))
        {
          if (newValue != null)
          {
              if (newValue.equalsIgnoreCase("true"))
              {
                  debug = true;
              }
          } else
          {
              debug = false;
          }
        }
    }   
}
