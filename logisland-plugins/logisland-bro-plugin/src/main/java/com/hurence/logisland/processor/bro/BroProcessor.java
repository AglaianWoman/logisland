/**
 * Copyright (C) 2017 Hurence
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hurence.logisland.processor.bro;

import com.hurence.logisland.annotation.documentation.CapabilityDescription;
import com.hurence.logisland.annotation.documentation.Tags;
import com.hurence.logisland.component.PropertyDescriptor;
import com.hurence.logisland.processor.*;
import com.hurence.logisland.record.FieldDictionary;
import com.hurence.logisland.record.Record;
import com.hurence.logisland.util.string.JsonUtil;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Bro (https://www.bro.org/) processor
 */
@Tags({"bro"})
@CapabilityDescription(
        "The Bro (https://www.bro.org) processor is the Logisland entry point to get and process Bro events."
        + " The Bro-Kafka plugin (https://github.com/bro/bro-plugins/tree/master/kafka ) should be used and configured"
        + " in order to have Bro events sent to Kafka  Then this Bro processor will do some minor pre-processing on"
        + " incoming Bro events to adapt them to Logisland. Then following processor in the stream can then process the"
        + " Bro events generated by this Bro processor.")
public class BroProcessor extends AbstractProcessor {

    private static Logger logger = LoggerFactory.getLogger(BroProcessor.class);
    
    private static Map<String, String> broFieldToLogislandField = new HashMap<String, String>();
    
    // Bro conn fields
    private static final String BRO_CONN_ID_ORIG_H = "id.orig_h";
    private static final String BRO_CONN_ID_RESP_H = "id.resp_h";
    private static final String BRO_CONN_ID_ORIG_P = "id.orig_p";
    private static final String BRO_CONN_ID_RESP_P = "id.resp_p";
    
    // Logisland conn fields
    
    private static final String LOGISLAND_CONN_SOURCE_IP = "source_ip";
    private static final String LOGISLAND_CONN_DEST_IP = "dest_ip";
    private static final String LOGISLAND_CONN_SOURCE_PORT = "source_port";
    private static final String LOGISLAND_CONN_DEST_PORT = "dest_port";
    
    static {
        // Bro conn fields mapping
        broFieldToLogislandField.put(BRO_CONN_ID_ORIG_H, LOGISLAND_CONN_SOURCE_IP);
        broFieldToLogislandField.put(BRO_CONN_ID_RESP_H, LOGISLAND_CONN_DEST_IP);
        broFieldToLogislandField.put(BRO_CONN_ID_ORIG_P, LOGISLAND_CONN_SOURCE_PORT);
        broFieldToLogislandField.put(BRO_CONN_ID_RESP_P, LOGISLAND_CONN_DEST_PORT);
    }

    @Override
    public void init(final ProcessContext context)
    {
        logger.debug("Initializing Bro Processor");
        
        // TODO add a config property to allow changing default bro fields mapping
        // Be sure that Issue https://github.com/Hurence/logisland/issues/135 is fixed for that
    }
    
    @Override
    public List<PropertyDescriptor> getSupportedPropertyDescriptors() {
        // TODO Auto-generated method stub
        return null;
    }
  
    @Override
    public Collection<Record> process(ProcessContext context, Collection<Record> records)
    {
        logger.debug("Bro Processor records " + records);

        /**
         * Get the original Bro event as a JSON string and do some adaptation like
         * changing some field names:
         * - Bro field names with '.' are not acceptable for indexing into ES. Change them with something more
         * user friendly if needed but in any case, replace the ES unwanted characters like '.'.
         */
        for (Record record : records)
        {
            String recordValue = (String)record.getField(FieldDictionary.RECORD_VALUE).getRawValue();
            
            // Parse as JSON object
            Map<String, Object> jsonBroEvent = JsonUtil.convertJsonToMap(recordValue);

            if (jsonBroEvent.isEmpty())
            {
                logger.error("Empty Bro event or error while parsing it: " + record);
                continue;
            }
            
            if (jsonBroEvent.size() != 1)
            {
                logger.error("Bro event should have one bro event type field: " + record);
                continue;
            }
            
            Map.Entry<String, Object> eventTypeAndValue = jsonBroEvent.entrySet().iterator().next();
            
            String broEventType = eventTypeAndValue.getKey();
            Object broEventValue = eventTypeAndValue.getValue();
            
            Map<String, Object> finalBroEvent = null; 
            try {
                finalBroEvent = (Map<String, Object>)broEventValue;
            } catch(Throwable t)
            {
                logger.error("Cannot understand bro event content: " + record);
                continue;
            }
            
            //finalBroEvent = replaceKeys(finalBroEvent, broFieldToLogislandField);
            normalizeFields(finalBroEvent, broFieldToLogislandField);                       
            
            String newRecordValue = JsonUtil.convertToJson(finalBroEvent);
            
            setBroEventFieldsAsFirstLevelFields(finalBroEvent, record);
             
            logger.debug("newRecordValue: " + newRecordValue);
            record.setStringField(FieldDictionary.RECORD_VALUE, newRecordValue);
            // Overwrite default reord_type field to indicate to ES processor which index type to use 
            // (index type is the bro event type)
            record.setStringField(FieldDictionary.RECORD_TYPE, broEventType);
            
            logger.debug("new Bro record: " + record);
        }

        logger.debug("################## Bro Processor output records " + records);
        return records;
    }
    
    /**
     * Gets the JSON content 
     * @param record
     */
    private static void setBroEventFieldsAsFirstLevelFields(Map<String, Object> broEvent, Record record)
    {
        for (Map.Entry<String, Object> jsonEntry : broEvent.entrySet())
        {
            String key = jsonEntry.getKey();
            Object value = jsonEntry.getValue();
            if (value instanceof String)
            {
                record.setStringField(key, value.toString());
            } else
            {
                if (!(value instanceof Map))
                {
                    logger.debug(key + " value type -> " + value.getClass().getName());
                }
                record.setStringField(key, JsonUtil.convertToJson(value));
            }
        }
    }
    
    /**
     * Normalize keys in the JSON
     * Change special keys or remove ES unwanted characters in JSON field keys
     * @param broEvent
     */
    private static void normalizeFields(Map<String, Object> broEvent, Map<String, String> oldToNewKeys)
    {
        List<String> keys = new ArrayList<String>(); // Do not modify the map while iterating over it
        for (String key : broEvent.keySet())
        {
            keys.add(key);
        }
        for (String key : keys)
        {
            Object value = broEvent.get(key);
            // Is it a key to replace ?
            String newKey = null;
            if (oldToNewKeys.containsKey(key))
            {
                newKey = oldToNewKeys.get(key);
            } else
            {
                // Not a special key to replace but we must at least remove unwanted characters
                if (key.contains("."))
                {
                    newKey = key.replaceAll("\\.", "_");
                }
            }            
            
            // Compute new value
            Object newValue = null;
            if (value instanceof Map)
            {
                Map<String, Object> map = (Map<String, Object>)value;
                normalizeFields(map, oldToNewKeys);
                newValue = map;
            } else
            {
                newValue = value;
            }
            
            if (newKey != null)
            {
                broEvent.remove(key);
                broEvent.put(newKey, newValue);
            }   
        }
    }
    
    @Override
    public void onPropertyModified(PropertyDescriptor descriptor, String oldValue, String newValue) {

        logger.debug("property {} value changed from {} to {}", descriptor.getName(), oldValue, newValue);              
    }   
}
